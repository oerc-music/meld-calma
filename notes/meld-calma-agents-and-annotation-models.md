MELD/CALMA data model notes

Initially copied from [20190604 meeting notes](planning/20190604-meeting.md).

These are working/tentative design notes, not yet a fixed design.


# Supporting structures

## Song workset

We have agreeed that for presentation to SOFA, the key workset will be a *recording* workset.  The song workset arises from the process of candidate song selection based on number of recordings, etc.  Thus, there is no single entry point (unless one considers the entire CALMA/eTree database.)

When introduced, a "song workset" will follows the general structure of a SOFA workset, but references songs rather than to fragments.  The members of a song workset could look something like this:

    @prefix ldp:  <http://www.w3.org/ns/ldp#>.
    @prefix dc:   <http://purl.org/dc/elements/>.
    @prefix dct:  <http://purl.org/dc/terms/>.
    @prefix meld: <http://example.com/meld/>.         @@@TODO proper namespace URI
    @prefix mc:   <http://example.com/meldedcalma/>.  @@@TODO proper namespace URI
    
    <>
        a mc:SongRef, meld:ItemRef, ldp:Resource;
        dc:creator "John";
        dct:created "2019-06-01T14:09:58+0100";
        meld:ref <artists_songs/Mogwai_xyz/song_xyz.ttl>
        .

Thus, a "Song workset" represents some collection of songs, which may be used to scope a series of related agent and client operations.

A song workset URI is the URI of a an LDP/Solid container, whose individual members are `SongRef` values (see below) describing indiviudual songs.  Thus new songs are added by adding new `SongRef` resources.

Song workset container-level metadata includes:

    mc:artists         (reference to artists container)         // see below
    mc:artist_songs    (reference to artist songs container)    // see below
    mc:annotationIndex (reference to feature index container)   // see below

There may be any number of these worksets.

See [here](https://thalassa2.oerc.ox.ac.uk:4443/public/workset1/) for example of a SOFA workset.

For our initial work, we are using a workset of just one song, which is specified in a command line argument to the relevant annotation agents.  (This means the song selection agent functionality is somewhat moot, and is being skipped in our initial implementation.)

## Recording workset

(See also: "song workset" above.)

The design for SOFA uses a working set as its entry structure for scoping searches for musical entities (fragments) and features (match/selection criteria).  Following this desiogn, the MELD/CALMA will be driven by a recording workset, containing references to recordings for which analysis data is presented, and also the workset container metadata includes a reference to a feature index (like the SOFA match service index) that can indicate the range of analysis featiures available for presentation.  Ther workset container should also contain a reference to the song presented by the various recordings.

A recording workset is generated by the processing of a selected song, and is subsequently passed to SOFA for scoping the display of musical features scross recordings.

A "recording workset" follows the structure of a SOFA workset that contains references to CALMA recordings rather than to fragments.  This will contain references to some subset of the recordings of songs in the corresponding "Song workset".  The members of a recording workset container look something like this:

    @prefix ldp:  <http://www.w3.org/ns/ldp#>.
    @prefix dc:   <http://purl.org/dc/elements/>.
    @prefix dct:  <http://purl.org/dc/terms/>.
    @prefix meld: <http://example.com/meld/>.         @@@TODO proper namespace URI
    @prefix mc:   <http://example.com/meldedcalma/>.  @@@TODO proper namespace URI
    
    <>
        a mc:RecordingRef, meld:ItemRef, ldp:Resource;
        dc:creator "John";
        dct:created "2019-06-01T14:09:58+0100";
        meld:ref <CALMA recording URI>
        .

The intent is that as each recording of a song is processed, its details are stored in a "Recording workset" corresponding to that song, which can be used to enumerate (or scope) the subsequent activities of annotation agents and the display (remixer) client.

A recording workset container should contain a reference to the song that is the subject the various recordings.


## Recording workset feature index

The intent here is that a specified or directly discoverable workset container will contain references to all other containers referenced by the display (remixer) client software.  There should be enough information to allow containers to be located without explicit prior knowledge beyond the general data model schema - the software should be able to work with annotation containers (and worksets) stored at arbitrary, distributed locations.

The feature index is itself an annotation container, which should be created and linked when the Song workset container is created.

Each song-related annotation container created or populated by one of the agents will have an index entry like this:

    <> a oa:Annotation ;
      oa:motivatedBy mc:FEATURE_INDEX ;        
      oa:hasTarget (feature identifier) ;   // A known constant, not necessarily dereferencable.
      oa:hasBody   (feature container) ;    // URL of feature annotation container
      .

See also "workset_feature_index" in "Song selection agent" below?


# Agent landscape

We discussed what further agents will be needed, and data models for the annotations they would create.

![MELD/CALMA music flows](images/20190604-MELD-CALMA-flows.jpg)

The notes below focus on the data models for the annotations produced by the various agents.

## Song-to-signal agent

Includes structure to allow us to associate artist resources with artist names.

Proposed, then, is something like:

    /public

      /artists
        /artist_xyz.ttl
          <> a mc:Artist (?) ;
            rdfs:label "xyz" ;
            mc:artist_name "xyz" ;
            mc:etree_artist_id <xyz> ; // (full URI in etree)
            . 

      /artists_songs
        /Mogwai_xyz
          mc:artist </public/artists/artist_Mogwai.ttl> ;   // (URIref link to entry in /artists)
                                                            // Stored as container metadata

          /song_xyz.ttl
            <> a mc:Song (?) ;
              rdfs:label "Acid Food by Mogwai" ;
              mc:song_name "Acid Food" ;
              mc:artist </public/artists/artist_Mogwai.ttl> ;  // (URIref link to entry in /artists)
              mc:etree_song_id <xyzxyz> ; // (full URI in etree)
              .
          :

      /song_to_recording
        /song_annotation_xyz.ttl
          <> a oa:Annotation ;
            oa:motivatedBy mc:SONG_TO_RECORDING ;
            oa:hasTarget </public/artists_songs/artist_xyz/song_xyz.ttl> // URIref to entry in /artists_songs...
            oa:hasBody <etree_recording_id>
            .

And maybe later...

      /song_name_to_id          // Later support for alternative/mis-typed song names
        /song_annotation_xyz.ttl
          <> a oa:Annotation ;
            oa:motivatedBy mc:SONG_ID_NAME ;
            oa:hasTarget <...artists_songs/Mogwai_xyz/song_xyz.ttl...> or "song reference" (see below)
            oa:hasBody   [ mc:song_name "Acid Food", "acid food", "AcidFood", etc. ]
            .

      /artist_name_to_id      // If required to allow SOFA to access artist info without special interface
                              // Also possible support for alternative names
        /artist_annotation_xyz.ttl
          <> a oa:Annotation ;
            oa:motivatedBy mc:ARTIST_ID_NAME ;
            oa:hasTarget </public/artists/Mogwai_xyz> ;
            oa:hasBody   [ mc:artist_name "Mogwai" ] ;    // body is bnode; could (should?) have URI
            .


Note that the structure of container names here is illustrative: agents and clients should discover container references by following indexes rather than knowledge of the naming structure used.

Note that annotations are defined using the `<>` for a URI reference: this resolves to the URI of the containing resource, and can be used to dereference a fgiven annotation (e.g. if annotations are being processed from a graph of merged annotations.)

The "song to recording" annotation container is added to the "Song workset feature index"


## Fetch-and-unpack agent

Pulling summarized information from eTree/CALMA.  Also, note that CALMA data doesn't have globally unique IDs, so need to allocate these (JPNP).  (This is why the source data is kept in TAR files.)

For now, this functionality is incorporated directly into the song-to-signal agent.


## Number of occurrences agent

(Precursor for song selection agent.)

Create a container of annotations that target songs, and record a count of recordings available for each song.

    /public

      /song_number_of_occurrences
        /anno_song_xyz.ttl
          <> a oa:Annotation ;
            oa:motivatedBy mc:SONG_NUM_RECORDINGS ;
            oa:hasTarget <song_xyz> ;
            oa:hasBody   [ mc:number_of_recordings "n" ] ;
            .


## Song selection agent

Uses the number of occurrences annotations to create new worksets containing recordings of songs that satisfy the >=100 recordings criteria.  The "workset feature index" container contains annotation resources that connect "Recording workset containers" (see below) with feature annotation containers that relate to that workset.

As part of the process of song selection, a list of recording references is created in a "recording_workset_container" associated with that song.  (Later, the annotations may be extended to allow different songs to be treated as variations of the same Work.)

    /public

      /recording_workset_container
        /recording_xyz      -- (this is a workset container)
          <song reference>  -- (ref entry under /artist_songs??)
           :
          <recording references  -- (see "Recording workset" above)>
           :

Any agent that subsequently creates a feature annotation container for a recording workset should also add an annotation container index entry to the 

      /recording_workset_feature_index
        /recording_xyz            -- (this is a feature index container)
          /anno_workset_xyz.ttl   -- (this is index entry for a single freature)
            <> a oa:Annotation ;  -- (entry for each available feature)
              oa:motivatedBy mc:WORKSET_FEATURE_INDEX ;
              oa:hasTarget <recording_workset_container>
              oa:hasBody   <workset_feature_index_container>
              .

(The container names are arbitrary, and are discoverable by scanning and following links from the recordiong workset container.)


## Key distribution per recording agent

(Recording == track per CALMA?)

For a given recording-workset (created by Song selection agent), accesses the CALMA data for each recording and writes an annotation for each recording describing the key detection (key change event) information (containing detected keys and duration within recording).

@@TODO Structure here should be reviewed in light of "Key distribution per song agent" output.

The resulting annotations would have this general form:

    <> a oa:Annotation ;
        oa:motivatedBy mc:KEY_DISTRIBUTION ;
        oa:hasTarget (recording reference in recording workset)
        oa:hasBody [
            mc:key_id (key id) ;                    // ???
            mc:prevalence "(fraction)"^xsd:double ; // ???

            @@other details TBD, based on key distribution data for recording obtained from CALMA
            @@include transform info - vamp plugin, parameters, etc - see key_typicality.py outputs
            ];
      .

@@TODO: update this with details from TW' implementation.

Also, add a record of the annotation container to the "recording workset feature index" container (to allow selection of alternative features for typicality displays).

(@@currently, logic in key_typicality.py)


## Key distribution per song agent

For all recordings, compute an "average" key distribution across all recordings of a given song (workset), and create a per-song annotation recording this.

    <> a oa:Annotation ;
      oa:motivatedBy mc:SONG_KEY_PREVALANCE ;
      oa:hasTarget (song reference in song workset)
      oa:hasBody 
        [ mc:key_info 
          [ rdfs:label "Dd major" (e.g.)
            mc:key_id "(key id)"^^xsd:integer ;
            mc:average_prevalence "(fraction)"^(xsd:double) ;  // duration of key/duration of song * (something)
          ]
        ]
      .

@@TODO: update this with details from TW' implementation.

Also, add a record of the annotation container to the "recording workset feature index" container (to allow selection of alternative features for typicality displays).


## Key typicality agent

For each recording of a song, calculate a "key typicality" measure that represents deviation of that recording from average key distribution for the song as calculated by the "Key distribution per song agent", and create a per-recording annotation for this.

    <> a oa:Annotation ;
      oa:motivatedBy mc:RECORDING_KEY_TYPICALITY ;
      oa:hasTarget (recording reference in recording workset)
      oa:hasBody [ 
          mc:key_typicality "(fraction)"^(xsd:double) ;
          mc:key_info [ 
            mc:key_id (key id) ;
            mc:prevalence "(fraction)"^xsd:double ;
            mc:average_prevalence "(fraction)"^xsd:double ;=
          ]
        ]
      .

@@TODO Structure here should be reviewed in light of implemented "Key distribution per song agent" output.

Also, add a record of the annotation container to the "recording workset feature index" container (to allow selection of alternative features for typicality displays).


## SOFA display client

Allow selection of a feature (initially just key typicality) from the "feature index" (by way of a recording workset), and read the corresponding typicality annotations and use these to create an appropriate comparative display.






